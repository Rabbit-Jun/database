# database
조인과 카티션프로덕트에 대해서

'판매데이터 베이스에서 'banana'고객이 주문한 제품의 이름을 검색해보자.'

맨 처음 이 문제를 접했을 때 SELECT * from 주문 a, 제품 b ,고객 c where( a.주문제품=b.제품번호) and (c.고객아이디='banana');라고 적었다.

그러나 내가 예상한 것과 달리 너무 많은 행이 떠서 당황했다.

그 후 sql에 아래의 쿼리들과 select * from 제품; select * from 주문, select * from 고객; 을 띄운 후에 비교해봤다. 

1. SELECT * from 주문 a, 제품 b ,고객 c  where (a.주문제품=b.제품번호) and (a.주문고객='banana');

2. SELECT * from 주문 a, 제품 b  where (a.주문제품=b.제품번호) and (a.주문고객='banana');

3. SELECT * from 주문 a, 제품 b   where (a.주문제품=b.제품번호);

4. SELECT * from 주문 a, 제품 b ,고객 c where( a.주문제품=b.제품번호) and (c.고객아이디='banana');

 

알게 된 것

1번 쿼리문의 행(21)=2번의 실행 결과 나온 행(10개) * 고객 테이블의 행(7) 

,즉 주문.주문제품=제품.제품번호 에 고객 테이블의 각 행을 합쳐서(카티션프로덕트) 출력한게 1번 쿼리문이다.

4번 쿼리문의 행(10)= 고객 테이블에서 고객아이디 ='banana' 인 행(1개) * 3번 쿼리문의 행(10개)

즉, 위 1번 쿼리문과 4번 쿼리문을 비교한 결과 조인이란 양 테이블에서 공통된 속성을 하나의 행으로 합쳐서 출력하는 것이다.

조인 하지 않고 테이블만 가져다 from에 붙이면 카티션프로덕트 돼서 행의 갯수만 많아진다.

 

 

판매 데이터베이스에서 나이가 30세 이상인 고객이 주문한 제품의 번호와 주문일자를 검색해보자

SELECT 주문.주문제품, 주문.주문일자 from 고객, 주문 where (고객.고객아이디=주문.주문고객) and 고객.나이 >=30

 

필요한 값이 고객의 나이와 주문제품과 주문일자 이다 그러니 두 테이블을 합쳐야 하고 두 테이블에서 같은 도메인을 가진게 바로 고객아이디와=주문고객 이다

 

SELECT 제품.제품명 from 고객, 주문, 제품 where(고객.고객아이디 =주문.주문고객 and 제품.제품번호 =주문.주문제품) and (고객.고객이름='고명석')

 

판매 데이터베이스에서 고명석 고객이 주문한 제품의 제품명을 검색해보자

 

SELECT 제품.제품명 from 고객, 주문, 제품 where(고객.고객아이디 =주문.주문고객 and 제품.제품번호 =주문.주문제품) and (고객.고객이름='고명석')

고객 테이블을 보면 제품명이 없다 그러니 다른 제품과 관련있는 테이블과 조인하여 제품명을 얻어야 한다, 그러나 제품명과 고객 테이블에 공통되는 속성이 없으니 조인을 2번하여 제품명을 얻는다. 

 

inner join 사용해서 검색하기

SELECT 주문.주문제품, 주문.주문일자 from 고객 inner join 주문 on 고객.고객아이디=주문.주문고객 inner join 제품 on 주문.주문제품 =제품.제품번호 where 고객.나이 >=30

 

group by

고객의 아이디 ,고객이름 총주문회수 검색

 

아래의 두 쿼리문을 실행 했을 떄 

1. select 고객.고객아이디, 고객.고객이름 ,count(주문.주문제품) as 주문회수 from 고객 INNER JOIN 주문 ON 고객.고객아이디=주문.주문고객 group by 주문.주문고객

 

2. select 고객.고객아이디, 고객.고객이름 ,count(주문.주문제품) as 주문회수 from 고객 INNER JOIN 주문 ON 고객.고객아이디=주문.주문고객

 

1번의 쿼리문이 더 많은 쿼리문을 출력 한다 그 이유는 count()가 집계 함수이기 때문인데 집계함수는 해당 테이블 전체에 작용하고 같이 검색하는 다른 속성은 해당 테이블에 포함된 값중 하나를 랜덤으로 띄어줌, 이런 현상을 막기 위해서는 group by로 속성을 그룹화 하여 집계함수를 개별적으로 적용하게 해야 하는 것임

 (집계함수로 조건을 주고 싶을 때는 having절 사용 ,ex. select count(속성명) from 테이블 having count(속성명)>3)

 

 모든 고객의 고객의 아이디 ,고객이름 총주문회수 검색

SELECT 고객.고객아이디, 고객.고객이름, count(주문.주문제품)as 주문회수 from 고객 left join 주문 on 고객.고객아이디=주문.주문고객 group by 고객.고객아이디

 

left join을 하여 고객 테이블 전체를 끌어다 씀으로써 모든 고객이 나오도록 함

 

판매 데이터베이스에서 제품명,제조업체, 총판매량을 검색

 

SELECT 제품.제품명, 제품.제조업체, sum(주문.수량)as 총판매량 from 제품 inner join 주문 on 제품.제품번호=주문.주문제품 group by 제품.제품명

 

sum을 안하고 주문.수량 하면 해당 테이블에서 먼저 나온 값을 수량 속성값으로 넣는 듯

 

SELECT 제품.제품명, 제품.제조업체, 주문.수량 from 제품 left join 주문 on 제품.제품번호=주문.주문제품 group by 제품.제품명

 

제품 테이블을 모두 넣고 주문 테이블 조인 

 

SELECT * from 고객 right join 주문 on 주문.주문고객= 고객.고객아이디

주문 테이블 기준으로 조인

 

주문 하지 않는 고객 검샘

 

SELECT 고객.고객아이디, 고객.고객이름 from 고객 left join 주문 on 주문.주문고객= 고객.고객아이디 where 주문.주문제품 is null

 

달콤비스킷을 생상한 제조업체가 만든 제품들의 제품명과 단가를 검색해보자

select 제품.제품명, 제품.단가 from 제품 WHERE 제품.제조업체=( SELECT 제품.제조업체 from 제품 where 제품.제품명='달콤비스킷')

 

부속 질의문에서 제품명=달콤비스킷인 제조업체를 출력한후 본 질의문에서 제품.제조업체 = 부속질의문 출력문 인 제품명과 단가를 검색

 

적립금이 가장 많은 고객의 고객이름과 적립금을 검색해보자

SELECT 고객.고객이름,고객.적립금 from 고객 where 고객.적립금 =(SELECT max(고객.적립금) from 고객 )

 

banana고객이 주문한 제품의 제품명과 제조업체를 검색해보자

select 제품명,제조업체 from 제품 where 제품번호 in (SELECT 주문제품 from 주문 where 주문고객 ='banana')

 

주문 고객=banana인 주문 제품을 검색해서 제품번호와 값이 일치하면 제품명과 제조업체 검색

 

대한식품이 제조한 모든 제품의 단가보다 비싼 제품의 제품명,단가 제조업체를 검색해보자

select 제품명,단가,제조업체  from 제품 where 단가 > all(SELECT 단가 from 제품 where  제조업체='대한식품')

 

부속 질의문을 연산자로 비교할려면 all 또는 any를 써야 하나봄 ,이유로는 부속 질의문에 값이 여러개여서 인듯?

 

2019년 3월 15일에 제품을 주문한 고객의 고객이름을 검색해보자

select 고객이름 from 고객 where 고객아이디 =(SELECT 주문고객 from 주문 where 주문일자='2019-03-15')

또는

select 고객이름 from 고객 where EXISTS (SELECT * from 주문 WHERE 주문일자='2019-03-15' and 주문.주문고객=고객.고객아이디)

 

위의 두 쿼리문은 모두 부속질의문으로 조인(?)을 할 수 있음을 보여준다

 
